# 计算机图形学作业六


## Dream car

使用了：**Parametric Surfaces(Bezier)**、**Polygonal Meshed** 和 **Loop Subdivision** 三种技术。

使用 Bezier 曲面绘制了车壳部分，使用 Polygonal Meshed 和 Subdivision 两个技术绘制了车轮部分。

## 车壳部分

使用 Bezier曲面，参考相关资料，实现了 Bezier曲线 的计算部分代码：

```C++
for (int p = 0; p < LEN_PATCHES; p++) {
        for (int i = 0; i <= DEG; i++)
            for (int j = 0; j <= DEG; j++)
                CP[i][j] = carVertices[carPatches[p][i][j] - 1];

        for (int ru = 0; ru <= LENU - 1; ru++) {
            float u = 1.0 * ru / (LENU - 1);
            for (int rv = 0; rv <= LENV - 1; rv++) {
                float v = 1.0 * rv / (LENV - 1);

                Vertex &res = realVertices[p * LENU * LENV + ru * LENV + rv];
                res = {0.0, 0.0, 0.0};
                for (int i = 0; i <= DEG; i++) {
                    float poly_i = B(i, DEG, u);
                    for (int j = 0; j <= DEG; j++) {
                        float poly_j = B(j, DEG, v);
                        res.x += poly_i * poly_j * CP[i][j].x;
                        res.y += poly_i * poly_j * CP[i][j].y;
                        res.z += poly_i * poly_j * CP[i][j].z;
                    }
                }

                realColors[p * LENU * LENV * 3 + ru * LENV * 3 + rv * 3 + 0] = patchesColor[p][0] / 255;
                realColors[p * LENU * LENV * 3 + ru * LENV * 3 + rv * 3 + 1] = patchesColor[p][1] / 255;
                realColors[p * LENU * LENV * 3 + ru * LENV * 3 + rv * 3 + 2] = patchesColor[p][2] / 255;
            }
        }
    }
```

将整个车分为了 $10$ 个部分进行建模：

```C++
GLuint carPatches[][DEG + 1][DEG + 1] = {
        {{1,  2,  3,  4},  {5,  6,  7,  8},  {9,  10, 11, 12}, {13, 14, 15, 16}}, // 前弧
        {{17, 18, 19, 20}, {21, 22, 23, 24}, {25, 26, 27, 28}, {29, 30, 31, 32}}, // 车顶
        {{13, 14, 15, 16}, {13, 14, 15, 16}, {17, 18, 19, 20}, {17, 18, 19, 20}}, // 前盖
        {{29, 30, 31, 32}, {29, 30, 31, 32}, {33, 34, 35, 36}, {33, 34, 35, 36}}, // 后盖
        {{33, 34, 35, 36}, {37, 38, 39, 40}, {41, 42, 43, 44}, {45, 46, 47, 48}}, // 后狐
        {{1,  2,  3,  4},  {1,  2,  3,  4},  {45, 46, 47, 48}, {45, 46, 47, 48}}, // 底板
        {{1,  5,  9,  13}, {49, 50, 51, 52}, {53, 54, 55, 56}, {45, 41, 37, 33}}, // 右车门
        {{4,  8,  12, 16}, {57, 58, 59, 60}, {61, 62, 63, 64}, {48, 44, 40, 36}}, // 左车门
        {{52, 65, 66, 56}, {52, 65, 66, 56}, {17, 21, 25, 29}, {17, 21, 25, 29}}, // 右挡风
        {{60, 67, 68, 64}, {60, 67, 68, 64}, {20, 24, 28, 32}, {20, 24, 28, 32}}, // 左挡风
};
```

每个部分由 $4\times 4 = 16$ 个点组成的控制点进行绘制。

为了进行调试，在绘制同时也会绘制出了控制点之间的线段，这部分放到了 `#ifdef DEBUG` 的条件编译中。

## 轮子部分

使用了 loop Subdivision 和 Polygonal Meshed 两种技术。

首先手动构建了一个 `wheel.obj` 文件：

```
v 0.5 0.5 -0.2
v 0.5 0.5 0.2
v -0.5 0.5 0.2
v -0.5 0.5 -0.2
v 0.5 -0.5 -0.2
v 0.5 -0.5 0.2
v -0.5 -0.5 0.2
v -0.5 -0.5 -0.2
f 1 4 2
f 2 4 3
f 1 2 5
f 5 2 6
f 1 5 4
f 4 5 8
f 7 6 3
f 3 6 2
f 7 8 6
f 6 8 5
f 7 3 8
f 8 3 4
```

描述了一个长方体，其中的参数是对照最后效果进行调参得到的。

然后对该长方体进行 $5$ 次 Loop Subdivision, 细分结果格式化后输出为 `subdivisionOut.obj`文件，然后程序读入`subdivisionOut.obj`，通过 Polygonal Meshed 技术将轮子绘制出来。

subdivisionOut文件的部分数据：

```
v 0.3 0.3 -0.12
v 0.300195 0.300195 0.0801172
v -0.300195 0.200293 0.120078
v -0.200293 0.300195 -0.120078
v 0.300195 -0.200293 -0.120078
v 0.200293 -0.300195 0.120078
v -0.3 -0.3 0.12
v -0.300195 -0.300195 -0.0801172
v 0.128113 0.326233 -0.130493
v 0.0166016 0.433594 -0.00664062
... ...
f 5537 5536 1395
f 1094 4298 5539
f 4298 3 5538
f 4298 5538 5539
f 5539 5538 1394
f 1094 5539 5536
f 5539 1394 5540
f 5539 5540 5536
f 5536 5540 1395
f 1395 5540 5542
f 5540 1394 5541
f 5540 5541 5542
f 5542 5541 354
f 284 5537 5531
f 5537 1395 5543
f 5537 5543 5531
f 5531 5543 1392
f 1395 5542 5545
f 5542 354 5544
```

该文件是程序运行过程中产生的文件，程序会在运行过程中搜索并读取同目录下的`wheel.obj` 文件并且在同目录生成 `subdivisionOut.obj` 文件。然后再读取 `subdivisionOut.obj` 文件进行绘制。

轮子会以 `(0,0,0)` 为中心被绘制，然后通过 `model` 矩阵进行复制平移，移动到对应的位置。

## 最终效果

/截屏2020-12-13 下午4.40.32.png

/截屏2020-12-13 下午4.40.22.png

其中的白线连接了 Bezier 曲面的部分控制点，用于 Debug 。
通过注释`#define DEBUG`来删除白线：

/截屏2020-12-13 下午4.47.46.png

## 代码文件

- main.cpp : 主函数部分，包括初始化以及渲染部分，以及轮子的平移。对 `.obj` 文件的读取与显示(Polygonal Meshed)也写到了该文件中。
- bezier.h : Bezier 曲面部分，在该部分内实现了 Bezier 曲面的计算，控制点数据也写死在了该文件中。
- division.h : 实现了 Loop Subdivision ,在该部分内实现了对 `.obj` 文件的曲面细分，并且该部分可以将曲面细分的结果数据格式化输出到`.obj`文件中
- Camera.h/Camera.cpp : 摄像机类，为了使main.cpp文件尽可能简洁，其中关于摄像机方向设置以及移动都在摄像机类中实现。
- Shaders.h/Shaders.cpp : 着色器类，该类封装了对于着色器的读取、编译、链接以及对于着色器变量的捕获修改。
- vertexShader.glsl : 顶点着色器
- fragmentShader.glsl : 片段着色器

## 其他说明

- 使用 Clion 完成项目
- 使用库： `glfw 3.3`, `glm 0.9.8.5`
- 操作系统为 macOS

`MAC`下请使用命令行运行该程序，在本地测试中，直接双击可执行文件会导致错误，需要使用命令行来执行。